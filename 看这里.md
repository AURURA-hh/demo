# 用户管理中心

本身从业务来看这个项目的话，其实很简单的东西，所以就注重一套完整的流程开发是如何的

## 三层搭建

我们会有

- controller   用来给外界提供API接口来访问
- service     用来写具体的业务，即一个接口进行处理需要调用的方法
- mapper    用来和数据库进行交互
- entity/pojo/model   实体类，上面的创建一般需要实体类，这里从业务来看，就是一个User，User的字段既要在数据库中进行存储，也要在我们业务逻辑中进行读取处理，所以要综合一点
- utils   工具类 这种都是需要完成什么的任务来自定义的一个工具，例如转换等等

## 进一步写逻辑

这里我们一步步来进行业务逻辑的搭建，为了简单，我新建了一个TestUserController来进行迭代  去找代码来对比着看

1.1首先，我们要清楚，现在用了MyBatis-plus之后，我们UserService的实现类--UserServiceImpl是包含了很多方法的了，只不过没有明面上展现出来，它包含着一些基础的CRUD，所以在这里，我们先简单调用一下。

1.2简单测试了一下功能，只要能跑通，那就没有问题，其他的方法就不再赘述，具体有不会的就问AI即可。既然别人封装好的方法我们能调用，我们也能够自己来定义方法，所以我们现在来进行一个稍微复杂一些的逻辑编写，用户传来账号和密码，我们利用传来的账号和密码来进行注册。

1.2.1可以看到，我们就是将用户的账号和密码放到了User里面，然后就进行了保存，本身逻辑并不复杂

1.2.2 实际上这种情况下，这种用户的请求，有的时候字段会很多，比如带着十多个参数一起过来，我们方法如果一口气写十多个，很明显，这样太臃肿了，于是我们就有了dto这个概念，用于数据的整体存放，里面存放的全部都是请求的参数，当然有的时候响应的数据需要特殊整合的话，也是可以放到dto里面的，是Response.  同样这个接口的改动放到下面一个新的方法里面了

1.2.3 那么实际上，我们其实并不应该在controller层里面写这种业务代码（尽管现在看起来，它并不复杂），因为要保证，从controller层看来，我只用简单调用对应方法逻辑，然后得到应该有的数据，然后返回给前端即可，因此，我们的方法需要进行封装了

经过这四步迭代，我们就完成了一个真正方法的编写，实际上我们处理业务也是直接在第四步的基础上来进行的，因此先做到理解这套操作，随后再接触具体的业务逻辑。